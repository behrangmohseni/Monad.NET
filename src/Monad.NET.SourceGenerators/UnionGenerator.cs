using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Monad.NET.SourceGenerators;

/// <summary>
/// Source generator that creates Match methods for discriminated unions marked with [Union].
/// </summary>
[Generator]
public class UnionGenerator : IIncrementalGenerator
{
    private const string UnionAttributeSource = """
        namespace Monad.NET;

        /// <summary>
        /// Marks a type as a discriminated union, enabling source generation of Match methods.
        /// </summary>
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class UnionAttribute : global::System.Attribute
        {
            public UnionAttribute() { }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("UnionAttribute.g.cs", SourceText.From(UnionAttributeSource, Encoding.UTF8)));

        // Find all classes with [Union] attribute
        var unionTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Monad.NET.UnionAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, _) => GetUnionInfo(ctx))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        // Generate the source
        context.RegisterSourceOutput(unionTypes, static (ctx, info) => GenerateSource(ctx, info));
    }

    private static UnionInfo? GetUnionInfo(GeneratorAttributeSyntaxContext context)
    {
        var symbol = context.TargetSymbol as INamedTypeSymbol;
        if (symbol is null)
            return null;

        // Must be abstract and partial
        if (!symbol.IsAbstract)
            return null;

        var syntax = context.TargetNode as TypeDeclarationSyntax;
        if (syntax is null)
            return null;

        if (!syntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
            return null;

        // Find nested types that inherit from this type
        var cases = new List<UnionCase>();
        foreach (var member in symbol.GetTypeMembers())
        {
            if (member.BaseType?.Equals(symbol, SymbolEqualityComparer.Default) == true)
            {
                var caseName = member.Name;
                var camelCaseName = char.ToLowerInvariant(caseName[0]) + caseName.Substring(1);
                cases.Add(new UnionCase(caseName, member.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), camelCaseName));
            }
        }

        if (cases.Count == 0)
            return null;

        var ns = symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        var isRecord = syntax is RecordDeclarationSyntax;

        return new UnionInfo(
            symbol.Name,
            symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            ns,
            cases.ToImmutableArray(),
            isRecord);
    }

    private static void GenerateSource(SourceProductionContext context, UnionInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (info.Namespace is not null)
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var typeKeyword = info.IsRecord ? "record" : "class";
        sb.AppendLine($"partial {typeKeyword} {info.Name}");
        sb.AppendLine("{");

        // Generate Match<TResult> method
        GenerateMatchMethod(sb, info);

        // Generate Match (void) method
        GenerateMatchVoidMethod(sb, info);

        sb.AppendLine("}");

        context.AddSource($"{info.Name}.Union.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateMatchMethod(StringBuilder sb, UnionInfo info)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Pattern matches on all cases of this union, returning a result.");
        sb.AppendLine("    /// </summary>");

        // Method signature
        sb.Append("    public TResult Match<TResult>(");

        var parameters = info.Cases
            .Select(c => $"global::System.Func<{c.FullTypeName}, TResult> {c.ParameterName}")
            .ToList();

        sb.Append(string.Join(", ", parameters));
        sb.AppendLine(")");
        sb.AppendLine("    {");

        // Switch expression
        sb.AppendLine("        return this switch");
        sb.AppendLine("        {");

        foreach (var unionCase in info.Cases)
        {
            sb.AppendLine($"            {unionCase.FullTypeName} __case__ => {unionCase.ParameterName}(__case__),");
        }

        sb.AppendLine($"            _ => throw new global::System.InvalidOperationException($\"Unknown case: {{GetType().Name}}\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateMatchVoidMethod(StringBuilder sb, UnionInfo info)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Pattern matches on all cases of this union, executing an action.");
        sb.AppendLine("    /// </summary>");

        // Method signature
        sb.Append("    public void Match(");

        var parameters = info.Cases
            .Select(c => $"global::System.Action<{c.FullTypeName}> {c.ParameterName}")
            .ToList();

        sb.Append(string.Join(", ", parameters));
        sb.AppendLine(")");
        sb.AppendLine("    {");

        // Switch statement
        sb.AppendLine("        switch (this)");
        sb.AppendLine("        {");

        foreach (var unionCase in info.Cases)
        {
            sb.AppendLine($"            case {unionCase.FullTypeName} __case__:");
            sb.AppendLine($"                {unionCase.ParameterName}(__case__);");
            sb.AppendLine("                break;");
        }

        sb.AppendLine("            default:");
        sb.AppendLine($"                throw new global::System.InvalidOperationException($\"Unknown case: {{GetType().Name}}\");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }
}

internal sealed class UnionInfo
{
    public string Name { get; }
    public string FullTypeName { get; }
    public string? Namespace { get; }
    public ImmutableArray<UnionCase> Cases { get; }
    public bool IsRecord { get; }

    public UnionInfo(string name, string fullTypeName, string? ns, ImmutableArray<UnionCase> cases, bool isRecord)
    {
        Name = name;
        FullTypeName = fullTypeName;
        Namespace = ns;
        Cases = cases;
        IsRecord = isRecord;
    }
}

internal sealed class UnionCase
{
    public string Name { get; }
    public string FullTypeName { get; }
    public string ParameterName { get; }

    public UnionCase(string name, string fullTypeName, string parameterName)
    {
        Name = name;
        FullTypeName = fullTypeName;
        ParameterName = parameterName;
    }
}

